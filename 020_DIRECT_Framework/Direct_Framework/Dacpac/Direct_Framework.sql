/*
Deployment script for Direct_Framework

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar master "master"
:setvar msdb "msdb"
:setvar SSISDB "SSISDB"
:setvar DatabaseName "Direct_Framework"
:setvar DefaultFilePrefix "Direct_Framework"
:setvar DefaultDataPath "C:\Users\roela\AppData\Local\Microsoft\VisualStudio\SSDT\Direct_Framework"
:setvar DefaultLogPath "C:\Users\roela\AppData\Local\Microsoft\VisualStudio\SSDT\Direct_Framework"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
/*
The column [omd].[SOURCE_CONTROL].[INTERVAL_DATETIME] is being dropped, data loss could occur.

The column [omd].[SOURCE_CONTROL].[INTERVAL_END_DATETIME] is being dropped, data loss could occur.

The column [omd].[SOURCE_CONTROL].[INTERVAL_END_IDENTIFIER] is being dropped, data loss could occur.

The column [omd].[SOURCE_CONTROL].[INTERVAL_START_DATETIME] is being dropped, data loss could occur.

The column [omd].[SOURCE_CONTROL].[INTERVAL_START_IDENTIFIER] is being dropped, data loss could occur.

The column [omd].[SOURCE_CONTROL].[MODULE_ID] on table [omd].[SOURCE_CONTROL] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.
*/

IF EXISTS (select top 1 1 from [omd].[SOURCE_CONTROL])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
PRINT N'Dropping Foreign Key [omd].[FK_MODULE_INSTANCE_SOURCE_CONTROL]...';


GO
ALTER TABLE [omd].[SOURCE_CONTROL] DROP CONSTRAINT [FK_MODULE_INSTANCE_SOURCE_CONTROL];


GO
PRINT N'Starting rebuilding table [omd].[SOURCE_CONTROL]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [omd].[tmp_ms_xx_SOURCE_CONTROL] (
    [MODULE_SOURCE_CONTROL_ID] BIGINT        IDENTITY (1, 1) NOT NULL,
    [MODULE_ID]                INT           NOT NULL,
    [MODULE_INSTANCE_ID]       INT           NOT NULL,
    [INSERT_DATETIME]          DATETIME2 (7) NULL,
    [START_VALUE]              DATETIME2 (7) NULL,
    [END_VALUE]                DATETIME2 (7) NULL,
    CONSTRAINT [tmp_ms_xx_constraint_PK_SOURCE_CONTROL1] PRIMARY KEY CLUSTERED ([MODULE_SOURCE_CONTROL_ID] ASC)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [omd].[SOURCE_CONTROL])
    BEGIN
        SET IDENTITY_INSERT [omd].[tmp_ms_xx_SOURCE_CONTROL] ON;
        INSERT INTO [omd].[tmp_ms_xx_SOURCE_CONTROL] ([MODULE_SOURCE_CONTROL_ID], [MODULE_INSTANCE_ID], [INSERT_DATETIME])
        SELECT   [MODULE_SOURCE_CONTROL_ID],
                 [MODULE_INSTANCE_ID],
                 [INSERT_DATETIME]
        FROM     [omd].[SOURCE_CONTROL]
        ORDER BY [MODULE_SOURCE_CONTROL_ID] ASC;
        SET IDENTITY_INSERT [omd].[tmp_ms_xx_SOURCE_CONTROL] OFF;
    END

DROP TABLE [omd].[SOURCE_CONTROL];

EXECUTE sp_rename N'[omd].[tmp_ms_xx_SOURCE_CONTROL]', N'SOURCE_CONTROL';

EXECUTE sp_rename N'[omd].[tmp_ms_xx_constraint_PK_SOURCE_CONTROL1]', N'PK_SOURCE_CONTROL', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Creating Foreign Key [omd].[FK_MODULE_INSTANCE_SOURCE_CONTROL]...';


GO
ALTER TABLE [omd].[SOURCE_CONTROL] WITH NOCHECK
    ADD CONSTRAINT [FK_MODULE_INSTANCE_SOURCE_CONTROL] FOREIGN KEY ([MODULE_INSTANCE_ID]) REFERENCES [omd].[MODULE_INSTANCE] ([MODULE_INSTANCE_ID]);


GO
PRINT N'Altering View [omd_reporting].[vw_CUMULATIVE_LOAD_TIME]...';


GO
ALTER view omd_reporting.vw_CUMULATIVE_LOAD_TIME
/***
Purpose: List accumulated load times for all modules. Handles if a table 
         has been reloaded.
***/
as

with pre_formatting
as  (
    select MODULE.MODULE_CODE,
        count(*) as instances_run,
        sum(datediff(second, MODULE_INSTANCE.START_DATETIME, coalesce(MODULE_INSTANCE.END_DATETIME, getdate()))) as duration_sec,
        sum(cast(MODULE_INSTANCE.ROWS_INSERTED as bigint)) as rows_transferred
    from omd.MODULE
    inner join omd.MODULE_INSTANCE on omd.MODULE_INSTANCE.MODULE_ID = omd.MODULE.MODULE_ID
    inner join (
                select 
                    MODULE_INSTANCE.MODULE_ID
                  , max(SOURCE_CONTROL.MODULE_INSTANCE_ID) as MODULE_INSTANCE_ID
                from omd.SOURCE_CONTROL
                inner join omd.MODULE_INSTANCE on omd.MODULE_INSTANCE.MODULE_INSTANCE_ID = omd.SOURCE_CONTROL.MODULE_INSTANCE_ID
                where omd.SOURCE_CONTROL.START_VALUE = '1900-01-01 00:00:00.0000000'
                group by MODULE_INSTANCE.MODULE_ID
                ) last_reloaded
            on last_reloaded.MODULE_ID = MODULE_INSTANCE.MODULE_ID
            and last_reloaded.MODULE_INSTANCE_ID <= MODULE_INSTANCE.MODULE_INSTANCE_ID
    group by omd.MODULE.MODULE_CODE
    )

select
    MODULE_CODE,
    instances_run,
    duration_sec,
    isnull(cast(nullif(datepart(day, dateadd(second, duration_sec, 0)), 1) - 1 as varchar(10)) + ' days ', '')
        +  convert(varchar(30), dateadd(second, duration_sec, 0), 108) as duration,
    rows_transferred
from pre_formatting;
GO
PRINT N'Creating Function [omd].[GetModuleLoadWindowValue]...';


GO
CREATE FUNCTION [omd].[GetModuleLoadWindowValue] ( @ModuleId BIGINT, @start_or_end TINYINT)
RETURNS DATETIME2(7) AS 
BEGIN 
    /*
        The GetModuleLoadWindowDateTime retrieves the start or end value as currently available in the source control table.
        The from part of the load window can be selected by providing the parameter value 1, and 2 is for the closing of the window - the end datetime.

        Example usage:

        DECLARE @START_VALUE DATETIME2(7) = [omd].[GetModuleLoadWindowDateTime]((SELECT MODULE_ID FROM [omd].MODULE WHERE MODULE_CODE='<module>'), 1)
        PRINT @START_VALUE

        Load windows can be created via omd.CreateLoadWindow.
    */
    DECLARE @result DATETIME2(7)
 
    IF @start_or_end = 1
    BEGIN
            SELECT @result= START_VALUE
            FROM
            (
                SELECT 
                sct.MODULE_INSTANCE_ID, 
                START_VALUE, 
                END_VALUE,
                ROW_NUMBER() OVER (PARTITION BY modinst.MODULE_ID ORDER BY INSERT_DATETIME DESC) AS ROW_NR 
            FROM omd.SOURCE_CONTROL sct
            JOIN omd.MODULE_INSTANCE modinst ON sct.MODULE_INSTANCE_ID = modinst.MODULE_INSTANCE_ID
            WHERE modinst.MODULE_ID = @ModuleId
            ) ranksub
            WHERE ROW_NR=1
    END
    ELSE IF @start_or_end = 2
    BEGIN
            SELECT @result= END_VALUE
            FROM
            (
                SELECT 
                sct.MODULE_INSTANCE_ID, 
                START_VALUE, 
                END_VALUE,
                ROW_NUMBER() OVER (PARTITION BY modinst.MODULE_ID ORDER BY INSERT_DATETIME DESC) AS ROW_NR 
            FROM omd.SOURCE_CONTROL sct
            JOIN omd.MODULE_INSTANCE modinst ON sct.MODULE_INSTANCE_ID = modinst.MODULE_INSTANCE_ID
            WHERE modinst.MODULE_ID = @ModuleId
            ) ranksub
            WHERE ROW_NR=1
    END
    RETURN @result
END
GO
PRINT N'Altering Procedure [omd].[GetConsistencyDateTime]...';


GO
/*
Process: Get Consistenct Date/Time
Input: 
  - Table list (comma separated array)
  - Load Window Attribute (optional)
  - Measurement Date/Time (optional)
  - Debug flag Y/N
Returns:
  - Consistency Date/Time
Usage:
	DECLARE @ConsistencyDateTime DATETIME2(7)
	EXEC [omd].[GetConsistencyDateTime]
	  @TableList ='HUB_CUSTOMER, SAT_CUSTOMER, SAT_CUSTOMER_ADDITIONAL_DETAILS',
	  @LoadWindowAttributeName = 'LOAD_DATETIME',
	  @Debug = 'Y',
	  @ConsistencyDateTime = @ConsistencyDateTime OUTPUT
	PRINT @ConsistencyDateTime;

Intent:
   For a given point in time, data will be consistent up to the lowest load window end-date of the most-recently successfully completed ETL execution instances involved in loading the target tables.
*/

ALTER PROCEDURE [omd].[GetConsistencyDateTime]
	@TableList VARCHAR(MAX),
	@MeasurementDateTime DATETIME2(7) = NULL,
	@LoadWindowAttributeName VARCHAR(255) = 'LOAD_DATETIME',
	@Debug VARCHAR(1) = 'N',
	@ConsistencyDateTime DATETIME2(7) = NULL OUTPUT
AS

BEGIN

  -- Input variables, for debugging only and commented out
  --DECLARE @TableList VARCHAR(MAX) ='HUB_CUSTOMER, SAT_CUSTOMER, SAT_CUSTOMER_ADDITIONAL_DETAILS'
  --DECLARE @MeasurementDateTime DATETIME2(7) = GETDATE();
  --DECLARE @Debug  CHAR(1) = 'Y';
  --DECLARE @ConsistencyDateTime DATETIME2(7);
  -- End of debug block

	IF @MeasurementDateTime IS NULL
		SET @MeasurementDateTime = GETDATE();

	DECLARE @NumberOfExpectedTargetTables INT; -- This is the number of tables expected to be loading, based on the input table array (table list). 
	DECLARE @NumberOfActualTargetTables INT; -- This is the number of tables found in the load window / module instance list. It needs to be the same as the expected target tables.
	-- If the number of actual target tables is lower than the expected target tables, some of the targets have never been loaded and the process should default to NULL.
	-- This can happen when the whole system is truncated, or started anew.

	DECLARE @ChangeModuleCount INT; -- The number of changes, as per changes in the load window. This is the sum of the delta change indicator.
	-- If there are no changes, the max load window can be used as it wouldn't have changed.

	DECLARE @EventDetail VARCHAR(4000);
	DECLARE @EventReturnCode INT;

	IF @Debug = 'Y'
	BEGIN
		PRINT 'Measurement date /time is '+CONVERT(VARCHAR(20),@MeasurementDateTime);
		PRINT 'Consistency date time algorithm started for input table array:';
		PRINT @TableList
	END

	DECLARE @TableNames TABLE
	(
		TABLE_NAME VARCHAR(MAX)
	);

  -- Region table name interpretation
  BEGIN TRY
	-- Remove spaces and quotes
	SET @TableList = REPLACE(@TableList,' ','');
	SET @TableList = REPLACE(@TableList,'''','');

	-- Splitting the Table_List variable array into rows
	-- Would fail if passed a list of more than 100 tables
	WITH cteSplits(starting_position, end_position)
	AS
	(
	  SELECT CAST(1 AS BIGINT), CHARINDEX(',', @TableList)
	  UNION ALL
	  SELECT end_position + 1, charindex(',', @TableList, end_position + 1)
	  FROM cteSplits
	  WHERE end_position > 0 -- Another delimiter was found
	)
	, table_names
	AS
	(
	  SELECT DISTINCT DATA_STORE_CODE = substring
												 (
												  @TableList,
												  starting_position,
												  CASE WHEN end_position = 0 
													   THEN len(@TableList)
													   ELSE end_position - starting_position
												  END
												 )
	FROM cteSplits
	)
	INSERT @TableNames 
	SELECT * FROM table_names

	IF @Debug = 'Y'
	BEGIN
	  PRINT 'The following rows are found interpreting the table array.'
	  DECLARE @xmltmp xml = (SELECT * FROM @TableNames FOR XML PATH(''))
	  PRINT CONVERT(NVARCHAR(MAX), @xmltmp)
	END

  END TRY
  BEGIN CATCH
	-- Logging
	SET @EventDetail = 'Error occurred when transposing table array. The error is.'+ERROR_MESSAGE();
	THROW 50000,@EventDetail,1;
  END CATCH
  -- End of table interpretation

  -- Load window interpretation 
  IF @Debug='Y'
	PRINT 'Commencing load window retrieval';

  DECLARE @LoadWindows TABLE
  (
	INTERVAL_END_DATETIME_ORDER INT,
	MODULE_CODE VARCHAR(256),
	START_VALUE DATETIME2(7),
	END_VALUE DATETIME2(7),
	DATA_OBJECT_SOURCE VARCHAR(256),
	DATA_OBJECT_TARGET VARCHAR(256),
	EXECUTION_STATUS_CODE CHAR(1),
	CHANGE_DELTA_INDICATOR INT,
	MODULE_INSTANCE_ID INT,
	MODULE_ID INT,
	CHANGE_FOR_LOGICAL_SOURCE_GROUP CHAR(1)
  );

  BEGIN TRY

	WITH LoadWindowCte
	AS
	(
	SELECT
	  ROW_NUMBER() OVER (PARTITION BY DATA_OBJECT_SOURCE ORDER BY DATA_OBJECT_SOURCE, END_VALUE) as INTERVAL_END_DATETIME_ORDER,
	  MODULE_CODE,
	  START_VALUE,
	  END_VALUE,
	  DATA_OBJECT_SOURCE,
	  DATA_OBJECT_TARGET,
	  EXECUTION_STATUS_CODE,
	  CHANGE_DELTA_INDICATOR,
	  MODULE_INSTANCE_ID,
	  MODULE_ID
	FROM (
	  SELECT
		module.MODULE_CODE,
		sct.START_VALUE,
		sct.END_VALUE,
		module.DATA_OBJECT_SOURCE,
		module.DATA_OBJECT_TARGET,
		modinst.EXECUTION_STATUS_CODE,
		CASE
			WHEN sct.START_VALUE = sct.END_VALUE THEN 0
			ELSE 1
		END as CHANGE_DELTA_INDICATOR,
		ROW_NUMBER() OVER (PARTITION BY COALESCE(modinst.MODULE_ID,0) ORDER BY modinst.MODULE_INSTANCE_ID DESC) AS ROW_ORDER,
		sct.MODULE_INSTANCE_ID,
		modinst.MODULE_ID
	  FROM omd.MODULE_INSTANCE modinst
	  JOIN omd.SOURCE_CONTROL sct ON modinst.MODULE_INSTANCE_ID = sct.MODULE_INSTANCE_ID
	  JOIN omd.MODULE module ON modinst.MODULE_ID = module.MODULE_ID
	  JOIN -- Only join modules that relate to the intended target tables.
	  (
		SELECT MODULE_ID
		FROM omd.MODULE
		INNER JOIN @TableNames table_names ON LTRIM(table_names.TABLE_NAME) = omd.MODULE.DATA_OBJECT_TARGET
	  ) module_tables
	  ON modinst.MODULE_ID = module_tables.MODULE_ID
	  WHERE 1=1
		AND module.INACTIVE_INDICATOR='N'
		AND modinst.EXECUTION_STATUS_CODE = 'S'
		AND sct.END_VALUE <= @MeasurementDateTime
	) sub
	WHERE ROW_ORDER=1
	)

	, ChangesPerLogicalSource AS
	(
		SELECT
			DATA_OBJECT_SOURCE,
			CASE WHEN SUM(CHANGE_DELTA_INDICATOR) >0 THEN 'Y' ELSE 'N' END AS CHANGE_FOR_LOGICAL_SOURCE_GROUP 
		FROM LoadWindowCte cte
		GROUP BY DATA_OBJECT_SOURCE
	)

	INSERT @LoadWindows 
	SELECT 
		INTERVAL_END_DATETIME_ORDER, 
		MODULE_CODE,
		START_VALUE,
		END_VALUE,
		LoadWindowCte.DATA_OBJECT_SOURCE,
		DATA_OBJECT_TARGET,
		EXECUTION_STATUS_CODE,
		CHANGE_DELTA_INDICATOR,
		MODULE_INSTANCE_ID,
		MODULE_ID,
		CHANGE_FOR_LOGICAL_SOURCE_GROUP
	FROM LoadWindowCte 
	INNER JOIN ChangesPerLogicalSource 
		ON LoadWindowCte.DATA_OBJECT_SOURCE = ChangesPerLogicalSource.DATA_OBJECT_SOURCE

	-- What this captures is the available load windows for the incoming modules.
	-- If there is a change (delta change indicator) this means that within a functional group (e.g. per source) there is a change and everything must wait to catch-up (within the context of this source).
	-- The interval end datetime order shows the lowest end-datetime per functional group / source and should be selected usually.
	-- The exception to manage is when other sources are reported up-to-date (no delta change indicators). In this case we must check if there are any waiting records in the PSA.

	IF @Debug = 'Y'
	BEGIN
		PRINT 'The following rows are found interpreting the table array.'
		DECLARE @xmltmp2 xml = (SELECT * FROM @LoadWindows FOR XML PATH(''))
		PRINT CONVERT(NVARCHAR(MAX), @xmltmp2)
	END

	END TRY
		BEGIN CATCH
		-- Logging
		SET @EventDetail = 'Error occurred when retrieving the associated load windows. The error is.'+ERROR_MESSAGE();
		THROW 50000,@EventDetail,1;
	END CATCH
	-- End of load window interpretation

	-- Begin of initialisation interpretation.
	-- This means that at least every target table has to be associated with loading processes into it, otherwise the system is still powering up.
	SELECT @NumberOfExpectedTargetTables = COUNT(TABLE_NAME) FROM @TableNames
	SELECT @NumberOfActualTargetTables = COUNT(DISTINCT DATA_OBJECT_TARGET) FROM @LoadWindows

	IF @Debug = 'Y'
	BEGIN
		PRINT 'The number of expected target tables is: '+CONVERT(VARCHAR(10),@NumberOfExpectedTargetTables);
		PRINT 'The number of expected target tables is: '+CONVERT(VARCHAR(10),@NumberOfActualTargetTables);
	END

	IF @NumberOfActualTargetTables < @NumberOfExpectedTargetTables
	BEGIN
		IF @Debug = 'Y'
			PRINT 'Difference in actual and expected target table, the Consistency Date/Time is defaulted to NULL';

		SET @ConsistencyDateTime = NULL;
		GOTO EndOfProcedure
	END
	-- End of initialisation interpretation

	-- Begin of up-to-date interpretation.
	-- This means that every process has an 'up-to-date' record, meaning the start- and end date/times for the load windows are the same. A closing record.
	SELECT @ChangeModuleCount = SUM(CHANGE_DELTA_INDICATOR) FROM @LoadWindows

	IF @Debug = 'Y'
		PRINT 'The number deltas (updated load windows) is: '+CONVERT(VARCHAR(10),@ChangeModuleCount);

	IF @ChangeModuleCount = 0
	BEGIN
		PRINT 'There are no changed load windows for any of the corresponding modules, so everything is up to date. The max load window can be used.';
		SELECT @ConsistencyDateTime = MAX(END_VALUE) FROM @LoadWindows
		GOTO EndOfProcedure
	END
	-- End of up-to-date interpretation

	-- Beginning of load window evaluation.
	IF @Debug = 'Y'
	BEGIN
		PRINT 'Commencing load window evaluation. The lowest load window end date/time denominator is used for further validation. This is the local load window end datetime.'+CHAR(13);
	END

	BEGIN TRY

	--SELECT * FROM @LoadWindows WHERE INTERVAL_END_DATETIME_ORDER=1

	DECLARE @ConsistencyDateTimeTable TABLE
	(
		DATA_OBJECT_SOURCE VARCHAR(256),
		UP_TO_DATE_INDICATOR CHAR(1),
		CONSISTENCY_DATETIME DATETIME2(7)
	);

	DECLARE @localDataObjectSource VARCHAR(256);
	DECLARE @localIntervalEndDatetime DATETIME2(7);
	DECLARE @localChangeForLogicalGroup CHAR(1);
	DECLARE @localSqlStatement NVARCHAR(MAX);

	DECLARE datetime_cursor CURSOR FOR 
	SELECT
		DATA_OBJECT_SOURCE,
		END_VALUE,
		CHANGE_FOR_LOGICAL_SOURCE_GROUP
	FROM @LoadWindows 
	WHERE INTERVAL_END_DATETIME_ORDER=1

	OPEN datetime_cursor
	FETCH NEXT FROM datetime_cursor INTO @localDataObjectSource, @localIntervalEndDatetime, @localChangeForLogicalGroup

	WHILE @@FETCH_STATUS = 0
	BEGIN

		IF @Debug = 'Y'
		BEGIN
			PRINT CHAR(13)+'Working on '+@localDataObjectSource+' with change for logical group change indicator '+@localChangeForLogicalGroup+' an local load window end datetime '+CONVERT(VARCHAR(20),@localIntervalEndDatetime);
		END

		IF @localChangeForLogicalGroup = 'Y'
		BEGIN
			INSERT INTO @ConsistencyDateTimeTable VALUES (@localDataObjectSource, 'N', @localIntervalEndDatetime) 

			IF @Debug = 'Y'
				PRINT 'There is a change related to this logical group, so the miminum value will be saved for comparison with the other logical groups.';
		END

	-- If the logical group is up to date, e.g. there are no changes then lookups to the sources are required to assert if there are any outstanding rows.
		IF @localChangeForLogicalGroup = 'N'
		BEGIN
			DECLARE @localSourceMaxDateTime DATETIME2(7);
			SET @localSqlStatement = 'SELECT @localSourceMaxDateTime=COALESCE(MAX(LOAD_DATETIME),''1900-01-01'')' +
								   'FROM '+@localDataObjectSource+' sdo '+
								   'JOIN omd.MODULE_INSTANCE modinst ON sdo.module_instance_id=modinst.MODULE_INSTANCE_ID '+
								   'WHERE 1=1 '+
								   '--AND modinst.EXECUTION_STATUS_CODE=''S'' ' +
								   'AND LOAD_DATETIME <= '''+CONVERT(VARCHAR(100),@MeasurementDateTime)+''''

			-- Commented out EXECUTION_STATUS_CODE line because uncommitted rows should also be evaluated to prevent gaps in the load windows.
			-- Otherwise, status changes made to 'S' later on may be left out of the selection.

			IF @Debug = 'Y'
				PRINT @localSqlStatement;

			EXECUTE sp_executesql @localSqlStatement, N'@localSourceMaxDateTime DATETIME2(7) OUTPUT',@localSourceMaxDateTime=@localSourceMaxDateTime OUTPUT

			IF @Debug = 'Y'
				PRINT 'High water mark (localSourceMaxDateTime) in source table is: '+CONVERT(VARCHAR(20),@localSourceMaxDateTime);

			IF @localSourceMaxDateTime <= @localIntervalEndDatetime -- This table/mapping is up to date, and the results are not necessary to be considered.
			BEGIN
				INSERT INTO @ConsistencyDateTimeTable VALUES (@localDataObjectSource, 'Y', @localIntervalEndDatetime)

				IF @Debug = 'Y'
				BEGIN
					PRINT 'The high water mark (localSourceMaxDateTime) is the same as the load window. This source/target mapping is up to date.';
					PRINT 'The results can be eliminated from the algorithm, but is the consistency date/time is updated if null.';
				END

			END
			ELSE -- E.g. the values in the source are exceeding the load windows for the target
			BEGIN
				INSERT INTO @ConsistencyDateTimeTable VALUES (@localDataObjectSource, 'N', @localIntervalEndDatetime) 
				IF @Debug = 'Y'
					PRINT 'The high water mark (localSourceMaxDateTime) higher than the load window. There is a lag that needs to be managed.';
			END
		END

		FETCH NEXT FROM datetime_cursor INTO @localDataObjectSource, @localIntervalEndDatetime, @localChangeForLogicalGroup
	END

	CLOSE datetime_cursor
	DEALLOCATE datetime_cursor

	END TRY
	BEGIN CATCH
		-- Logging
		SET @EventDetail = 'The error is: '+ERROR_MESSAGE();
		THROW 50000,@EventDetail,1;
	END CATCH
	-- End load window evaluation.

	-- Final step calculate the consistency date/time using the condensed results for each logical group
	BEGIN TRY
		--SELECT * FROM @ConsistencyDateTimeTable
		SELECT @ConsistencyDateTime = MIN(CONSISTENCY_DATETIME) FROM @ConsistencyDateTimeTable WHERE UP_TO_DATE_INDICATOR='N'
	END TRY
	BEGIN CATCH
		-- Logging
		SET @EventDetail = ERROR_MESSAGE();
		THROW 50000,@EventDetail,1;
	END CATCH
	-- End of table interpretation

	EndOfProcedure:
	-- End label

	IF @Debug = 'Y'
	BEGIN
		PRINT 'End of procedure GetConsistencyDateTime';
		PRINT 'Consistency date/time is '+COALESCE(CONVERT(VARCHAR(20),@ConsistencyDateTime),'NULL');
	END
END
GO
PRINT N'Altering Procedure [omd].[AddModuleToBatch]...';


GO
/*
Process: Register Module to Batch
Purpose: Assigns a Module to be associated with a Batch. Both the Batch and Module must already exist.
Input: 
  - Module Code
  - Batch Code
  - Debug flag Y/N (defaults to N)
Returns:
  - Default Stored Procedure return code (no specific output)
Usage:
	DECLARE @BatchId INT
	EXEC [omd].[AddModuleToBatch]
		 @ModuleCode = 'MyNewModule'
		,@BatchCode = 'MyNewBatch'
		-- Non mandatory
		,@Debug = 'Y'
*/

ALTER PROCEDURE [omd].[AddModuleToBatch]
	@ModuleCode VARCHAR(255), -- Mandatory
	@BatchCode VARCHAR(255), -- Mandatory
	-- Optional
	@InactiveIndicator CHAR(1) = 'N',
	@Debug VARCHAR(1) = 'N'
AS

BEGIN

	DECLARE @ModuleId INT;
	DECLARE @BatchId INT;

	-- Find the Module Id
	BEGIN TRY
		SELECT @ModuleId = MODULE_ID FROM [omd].[MODULE] WHERE MODULE_CODE = @ModuleCode;

		IF @Debug = 'Y'
			BEGIN 
			IF @ModuleId IS NOT NULL
			PRINT 'Module Id '+CONVERT(VARCHAR(10),@ModuleId)+' has been retrieved for Module Code: '+@ModuleCode+'''.';
		ELSE
			BEGIN
				PRINT 'No Module Id has been found for Module Code '''+@ModuleCode+'''.';
				GOTO EndOfProcedureFailure
			END
	END
	END TRY
	BEGIN CATCH
		THROW 50000,'Incorrect Module Code specified.',1
	END CATCH

	-- Find the Batch Id
	BEGIN TRY
		SELECT @BatchId = BATCH_ID FROM [omd].BATCH WHERE BATCH_CODE = @BatchCode;

		IF @Debug = 'Y'
			BEGIN 
			IF @BatchId IS NOT NULL
			PRINT 'Batch Id '+CONVERT(VARCHAR(10),@BatchId)+' has been retrieved for Batch Code: '+@BatchCode+'''.';
		ELSE
			BEGIN
				PRINT 'No Batch Id has been found for Batch Code '''+@BatchCode+'''.';
				GOTO EndOfProcedureFailure
			END
	END
	END TRY
	BEGIN CATCH
		THROW 50000,'Incorrect Batch Code specified.',1
	END CATCH


	/* 
	  Batch - Module Registration.
	*/

	BEGIN TRY

		INSERT INTO [omd].[BATCH_MODULE] (BATCH_ID, MODULE_ID, INACTIVE_INDICATOR)
		SELECT *
		FROM 
		(
		  VALUES (@BatchId, @ModuleId, @InactiveIndicator)
		) AS refData( BATCH_ID, MODULE_ID, INACTIVE_INDICATOR)
		WHERE NOT EXISTS 
		(
		  SELECT NULL
		  FROM [omd].BATCH_MODULE bm
		  WHERE bm.BATCH_ID = refData.BATCH_ID AND bm.MODULE_ID = refData.MODULE_ID
		);

		IF @Debug = 'Y'
			BEGIN
				PRINT 'The Module '''+@BatchCode+''' ('+CONVERT(VARCHAR(10),@ModuleId)+') is associated with Batch '''+@BatchCode+''' ('+CONVERT(VARCHAR(10),@BatchId)+').';
				PRINT 'SELECT * FROM [omd].[BATCH_MODULE] where [BATCH_ID] = '+CONVERT(VARCHAR(10),@BatchId)+' and [MODULE_ID] = '+CONVERT(VARCHAR(10),@ModuleId)+'.';
			END

		GOTO EndOfProcedureSuccess
	END TRY
	BEGIN CATCH
		THROW
	END CATCH

	EndOfProcedureFailure:

	IF @Debug = 'Y'
		BEGIN
			PRINT CHAR(13)+'-- Batch/Module addition process encountered errors.';	
			GOTO EndOfProcedure
		END

	EndOfProcedureSuccess:

	IF @Debug = 'Y'
		BEGIN
			PRINT CHAR(13)+'-- Batch/Module addition process completed succesfully.';	
			GOTO EndOfProcedure
		END

	-- End label
	EndOfProcedure:

END
GO
PRINT N'Altering Procedure [omd].[BatchEvaluation]...';


GO
/*
Process: Batch Evaluation
Purpose: Checks if the Batch Instance is able to proceed, based on the state of all Batch Instances related to the particular Batch.
Input: 
  - Batch Instance Id
  - Debug flag Y/N (default to N)
Returns:
  - ProcessIndicator
Usage:
	DECLARE @ProcessIndicator VARCHAR(10);
	EXEC [omd].[BatchEvaluation]
	  @BatchInstanceId = <Id>,
	  @ProcessIndicator = @ProcessIndicator OUTPUT;
	PRINT @ProcessIndicator;
*/

ALTER PROCEDURE [omd].[BatchEvaluation]
	@BatchInstanceId INT, -- The Batch Instance Id
	@Debug VARCHAR(1) = 'N',
	@ProcessIndicator VARCHAR(10) = NULL OUTPUT
AS

BEGIN
  SET NOCOUNT ON;

  DECLARE @EventDetail VARCHAR(4000);
  DECLARE @EventReturnCode INT;

  DECLARE @BatchId INT;
  DECLARE @ActiveInstanceCount INT;

  IF @Debug = 'Y'
	PRINT '-- Beginning of Batch Evaluation for Batch Instance Id '+CONVERT(VARCHAR(10),@BatchInstanceId);

  SELECT @BatchId = omd.GetBatchIdByBatchInstanceId(@BatchInstanceId);

  -- Exception handling
  -- The Batch Id cannot be NULL
  IF @BatchId IS NULL
  BEGIN
	SET @EventDetail = 'The Batch Id was not found for Batch Instance Id '''+@BatchInstanceId+'''';  
	EXEC [omd].[InsertIntoEventLog]
	  @EventDetail = @EventDetail;
  END

  IF @Debug = 'Y'
	PRINT 'For Batch Instance Id '+CONVERT(VARCHAR(10),@BatchInstanceId)+' the Batch Id '+CONVERT(VARCHAR(10),@BatchId)+' was found in omd.BATCH.';

  /* 
	Region: Check for multiple active Batch Instances
	Multiple active instances indicate corruption in the DIRECT repository.
  */

  IF @Debug = 'Y'
	PRINT CHAR(13)+'-- Beginning of active instance checks.';
	   
  -- Check if there are no additional running instances other than the current Batch Instance. The count should be 0.
  SELECT @ActiveInstanceCount = COUNT(*)
  FROM omd.BATCH_INSTANCE 
  WHERE EXECUTION_STATUS_CODE = 'E' 
	AND BATCH_ID = @BatchId and BATCH_INSTANCE_ID < @BatchInstanceId            

  IF @Debug = 'Y'
  BEGIN
	PRINT 'The number of active Batch Instances is '+COALESCE(CONVERT(VARCHAR(10),@ActiveInstanceCount),'0')+'.';
  END

  IF @ActiveInstanceCount = 0
	BEGIN
	  -- Continue,  there is no other active instance for this Batch.
	  IF @Debug = 'Y'
		PRINT 'Either there are no other active instance for the Batch (except this one), so the evaluation can continue.'
	 
	 -- Go to the next step in the process.
	  GOTO BatchInactiveEvaluation
	END
  ELSE -- There are already multiple running instances for the same Batch, the process must be aborted.
	BEGIN
	  IF @Debug = 'Y'
		PRINT 'There are multiple running instances for the same Batch, the process must be aborted (abort and go to end of procedure).'

	  -- Call the Abort event.
	  EXEC [omd].[UpdateBatchInstance]
		@BatchInstanceId = @BatchInstanceId,
		@EventCode = N'Abort',
		@Debug = @Debug

	  SET @ProcessIndicator = 'Abort';
	  GOTO EndOfProcedure
	  -- End
	END

  BatchInactiveEvaluation:
  /* 
	Region: Batch active check.
	In case the Batch is has an INACTIVE_INDICATOR='N' the pcoess can be cancelled / skipped as the Batch is not supposed to run.
  */
  DECLARE @BatchInactiveIndicator VARCHAR(1);

  IF @Debug='Y'
	PRINT CHAR(13)+'-- Start of Batch Inactive evalation step.';
	
  SELECT @BatchInactiveIndicator = INACTIVE_INDICATOR
  FROM omd.BATCH
  WHERE BATCH_ID= @BatchId                

  IF @BatchInactiveIndicator = 'N' -- The Batch is enabled, so the process can continue.
	BEGIN

	  IF @Debug='Y'
		PRINT 'The Batch is enabled (Inactive Indicator is set to '+@BatchInactiveIndicator+'), so the process can continue.';

	  GOTO RollBackEvaluation -- Go to the next process step after this section.
	END
  ELSE -- Batch has something else than 'N' and should be skipped / cancelled.
	BEGIN 
	  IF @Debug='Y'
		PRINT 'The Batch is disabled (Inactive Indicator is set to '+@BatchInactiveIndicator+'), so the process must cancel / skip.';
			  
	  -- Call the Cancel (skip) event.
	  EXEC [omd].[UpdateBatchInstance]
		@BatchInstanceId = @BatchInstanceId,
		@EventCode = N'Cancel',
		@Debug = @Debug
	  
	  SET @ProcessIndicator = 'Cancel';
	  GOTO EndOfProcedure 
	END


  /* 
	Region: rollback.
	Any erroneous previous instances must be rolled-back before processing can continue.
  */
  RollBackEvaluation:

  IF @Debug='Y'
	PRINT CHAR(13)+'-- Start of rollback evaluation process step.';

  DECLARE @LastExecutionStatusCode VARCHAR(1);
  DECLARE @LastNextRunIndicator VARCHAR(1);

  -- Get the Next Run Indicator and Execution Status Code from the previous Batch Instance.
  DECLARE @PreviousBatchInstanceTable TABLE
  (
	LastExecutionStatusCode VARCHAR(1),
	LastNextRunIndicator VARCHAR(1)
  );

  INSERT @PreviousBatchInstanceTable 
  SELECT * FROM [omd].[GetPreviousBatchInstanceDetails](@BatchId)

  SELECT @LastExecutionStatusCode = LastExecutionStatusCode FROM @PreviousBatchInstanceTable;
  IF @Debug='Y'
	PRINT 'The previous Batch Instance Execution Status Code is '+@LastExecutionStatusCode;

  SELECT @LastNextRunIndicator = LastNextRunIndicator FROM @PreviousBatchInstanceTable;
  IF @Debug='Y'
	PRINT 'The previous Batch Instance Next Run Indicator is '+@LastNextRunIndicator;

  -- Proceed
  -- The execution can proceed if the previous run for the Batch (the previous Batch Instance) was without failure, was not set to rerun and was not cancelled.
  IF ( (@LastExecutionStatusCode != 'F') AND (@LastNextRunIndicator NOT IN ('C','R')) ) 
	BEGIN
	  IF @Debug='Y'
		PRINT 'The last Execution Flag is '+@LastExecutionStatusCode+' and last Next Run Indicator is '+@LastNextRunIndicator+'. The process can proceed (no rollback is required).';

	  IF @Debug='Y'
		PRINT 'The Batch Instance will be set to proceed';

	  EXEC [omd].[UpdateBatchInstance]
		@BatchInstanceId = @BatchInstanceId,
		@EventCode = N'Proceed',
		@Debug = @Debug

	   SET @ProcessIndicator = 'Proceed';
	   GOTO EndOfProcedure
	END

  -- Proceed with RollBack.
  -- If the previous Batch Instance has failed and the previous next run indicator is not set to skip OR the previous next run indicator is set to rerun the rollback step must be initiatied.
  IF ( (@LastExecutionStatusCode = 'F' AND @LastNextRunIndicator != 'C') OR @LastNextRunIndicator = 'R' ) 
	BEGIN
	  IF @Debug='Y'
		PRINT 'The last Execution Flag is '+@LastExecutionStatusCode+' and last Next Run Indicator is '+@LastNextRunIndicator+'. The process must initiate a rollback.';

	  IF @Debug='Y'
		PRINT 'The Batch Instance will be set to rollback.';

	 -- NOTE the below status update on the Batch Instance will always trigger a full rollback, whereas partial rollback is the default.
		  
	 -- EXEC [omd].[UpdateBatchInstance]
	 --   @BatchInstanceId = @BatchInstanceId,
		--@EventCode = N'Rollback',
	 --   @Debug = @Debug

	  SET @ProcessIndicator = 'Rollback';
	  GOTO CallRollback
	END


  /*
	Region: execution of rollback.
	Call the rollback procedure for the current Batch.
	Technically, this is disabling any Modules that were part of earlier failed Batches, as the rollback itself happens at Module level.
  */

  CallRollback:
  
  IF @Debug='Y'
	PRINT CHAR(13)+'-- Start of rollback evaluation process step.';

  DECLARE @SqlStatement VARCHAR(MAX);

  DECLARE @FailedBatchIdArray VARCHAR(MAX) = omd.[GetFailedBatchIdList](@BatchId);

  IF @Debug='Y'
	PRINT 'The array of earlier failed Batch Instances is '+@FailedBatchIdArray+'.';

  IF @LastNextRunIndicator = 'R' -- Full rollback for all Modules in the Batch.
	BEGIN  
	  BEGIN TRY

		SET @SqlStatement = 'UPDATE omd.MODULE_INSTANCE SET NEXT_RUN_INDICATOR = ''R'' WHERE BATCH_INSTANCE_ID IN '+@FailedBatchIdArray;

		IF @Debug='Y'
		  PRINT 'Rollback SQL statement (full) is: '+@SqlStatement;

		EXEC (@SqlStatement);

		-- After rollback is completed, the process is allowed to continue.
		IF @Debug='Y'
		  PRINT 'The Module Instance will be set to proceed';

		EXEC [omd].[UpdateBatchInstance]
		  @BatchInstanceId = @BatchInstanceId,
		  @EventCode = N'Proceed',
		 @Debug = @Debug

		SET @ProcessIndicator = 'Proceed';
		GOTO EndOfProcedure

	 END TRY
	 BEGIN CATCH

		-- Batch Failure
	   EXEC [omd].[UpdateBatchInstance]
		  @BatchInstanceId = @BatchInstanceId,
		  @Debug = @Debug,
		  @EventCode = 'Failure';
		SET @ProcessIndicator = 'Failure';

		-- Logging
	   SET @EventDetail = ERROR_MESSAGE();
	   SET @EventReturnCode = ERROR_NUMBER();
	   
	   EXEC [omd].[InsertIntoEventLog]
		 @BatchInstanceId = @BatchInstanceId,
		 @EventDetail = @EventDetail,
		 @EventReturnCode = @EventReturnCode;

	   THROW
	 END CATCH
  END

  IF @LastNextRunIndicator = 'P' -- Partial rollback - skip previously succesfull Modules in the Batch.
	BEGIN  
	  BEGIN TRY

		SET @SqlStatement = 'UPDATE omd.MODULE_INSTANCE SET NEXT_RUN_INDICATOR = ''C'' WHERE EXECUTION_STATUS_CODE!=''F'' AND BATCH_INSTANCE_ID IN '+@FailedBatchIdArray;

		IF @Debug='Y'
		  PRINT 'Rollback SQL statement (partial) is: '+@SqlStatement;

		EXEC (@SqlStatement);

		-- After rollback is completed, the process is allowed to continue.
		IF @Debug='Y'
		  PRINT 'The Batch Instance will be set to proceed';

		EXEC [omd].[UpdateBatchInstance]
		  @BatchInstanceId = @BatchInstanceId,
		  @EventCode = N'Proceed',
		 @Debug = @Debug

		SET @ProcessIndicator = 'Proceed';
		GOTO EndOfProcedure

	 END TRY
	 BEGIN CATCH
		-- Batch Failure
	   EXEC [omd].[UpdateBatchInstance]
		  @BatchInstanceId = @BatchInstanceId,
		  @Debug = @Debug,
		  @EventCode = 'Failure';
		SET @ProcessIndicator = 'Failure';

		-- Logging
	   SET @EventDetail = ERROR_MESSAGE();
	   SET @EventReturnCode = ERROR_NUMBER();
	   
	   EXEC [omd].[InsertIntoEventLog]
		 @BatchInstanceId = @BatchInstanceId,
		 @EventDetail = @EventDetail,
		 @EventReturnCode = @EventReturnCode;

	   THROW
	 END CATCH
  END

  -- All branches completed

  -- The procedure should not be able to end in this part.
  -- Batch Failure
  EXEC [omd].[UpdateBatchInstance]
	@BatchInstanceId = @BatchInstanceId,
	@Debug = @Debug,
	@EventCode = 'Failure';

  SET @ProcessIndicator = 'Failure';

  RAISERROR('Incorrect Batch Evaluation path encountered (post-rollback).',1,1)

  /*
	Region: end of processing, final step.
  */

  EndOfProcedure:
   -- End label

  IF @Debug = 'Y'
  BEGIN
	 BEGIN TRY
	   PRINT 'Batch Instance Id '+CONVERT(VARCHAR(10),@BatchInstanceId)+' was processed';
	   PRINT 'The result (processing indicator) is '+@ProcessIndicator;  
	   PRINT CHAR(13)+'-- Batch Evaluation completed.';
	 END TRY
	 BEGIN CATCH

	   -- Logging
	   SET @EventDetail = ERROR_MESSAGE();
	   SET @EventReturnCode = ERROR_NUMBER();
	   
	   EXEC [omd].[InsertIntoEventLog]
		 @BatchInstanceId = @BatchInstanceId,
		 @EventDetail = @EventDetail,
		 @EventReturnCode = @EventReturnCode;

	   THROW
	 END CATCH
  END

END
GO
PRINT N'Altering Procedure [omd].[CreateBatchInstance]...';


GO
/*
Process: Create Batch Instance
Input: 
  - Batch Code
  - Execution runtime Is (e.g. GUID, SPID)
  - Debug flag Y/N
Returns:
  - Batch Instance Id
Usage:
	DECLARE @BatchInstanceId INT
	EXEC [omd].[CreateBatchInstance]
	  @BatchCode = N'<Batch Code / Name>',
	  @BatchInstanceId = @BatchInstanceId OUTPUT;
	PRINT @BatchInstanceId;
*/

ALTER PROCEDURE [omd].[CreateBatchInstance]
	@BatchCode VARCHAR(255), -- The name of the Batch, as identified in the BATCH_CODE attribute in the BATCH table.
	@Debug VARCHAR(1) = 'N',
	@ExecutionRuntimeId VARCHAR(255) = 'N/A',
	@BatchInstanceId INT = NULL OUTPUT
AS
BEGIN

  DECLARE @EventDetail VARCHAR(4000);
  DECLARE @EventReturnCode INT;

  DECLARE @BatchId INT;
  SELECT @BatchId = omd.GetBatchIdByName(@BatchCode);

  -- Exception handling
  -- The Batch Id cannot be NULL
  IF @BatchId IS NULL
  BEGIN
	SET @EventDetail = 'The Batch Id was not found for Batch Code '''+@BatchCode+'''';  
	EXEC [omd].[InsertIntoEventLog]
	  @EventDetail = @EventDetail;
  END

  IF @Debug = 'Y'
	PRINT 'For Batch Code '+@BatchCode+' the following Batch Id was found in omd.BATCH: '+CONVERT(VARCHAR(10),@BatchId);

  BEGIN TRY

	INSERT INTO omd.BATCH_INSTANCE 
	(
	  BATCH_ID,  
	  START_DATETIME, 
	  EXECUTION_STATUS_CODE, 
	  NEXT_RUN_INDICATOR, 
	  PROCESSING_INDICATOR,
	  BATCH_EXECUTION_SYSTEM_ID
	)
	VALUES
	(
	  @BatchId,
	  SYSDATETIME(),        -- Start Datetime
	  'E',					-- Execution Status Code
	  'P',					-- Next Run Indicator
	  'A',					-- Processing Indicator
	  @ExecutionRuntimeId
	)
				

	SET @BatchInstanceId = SCOPE_IDENTITY();

	IF @Debug = 'Y'
	  PRINT 'A new Batch Instance Id '+CONVERT(VARCHAR(10),@BatchInstanceId)+' has been created for Batch Code: '+@BatchCode;

  END TRY
  BEGIN CATCH

	-- Logging
	SET @EventDetail = ERROR_MESSAGE();
	SET @EventReturnCode = ERROR_NUMBER();
	   
	EXEC [omd].[InsertIntoEventLog]
	  @BatchInstanceId = @BatchInstanceId,
	  @EventDetail = @EventDetail,
	  @EventReturnCode = @EventReturnCode;

	THROW
  END CATCH
  
END
GO
PRINT N'Altering Procedure [omd].[CreateLoadWindow]...';


GO
ALTER PROCEDURE [omd].[CreateLoadWindow]
  @ModuleInstanceId INT, -- The currently involved Module Instance Id
  @LoadWindowAttributeName VARCHAR(255) = 'INSCRIPTION_TIMESTAMP', -- Name of the attribute used to determine the load window
  @Debug CHAR(1) = 'N',
  @StartValue VARCHAR(MAX) = NULL OUTPUT, -- Can be datetime or identifier, datetime, whatever...
  @EndValue VARCHAR(MAX) = NULL OUTPUT
AS
BEGIN

/*
Process: Create Load Window
Input: 
  - Module Instance Id
  - Load Window Paramter (datetime or identifier)
  - Debug flag Y/N
Returns:
  - Load Window Start Date/Time or Identifier
  - Load Window End Date/Time or Identifier
Usage:
  DECLARE
		@StartValue datetime2(7),
		@EndValue datetime2(7)

  EXEC	[omd].[CreateLoadWindow]
		@ModuleInstanceId = '',
		@LoadWindowAttributeName = 'LOAD_DATETIME',
		@Debug = N'Y',
		@StartValue = @StartValue OUTPUT,
		@EndValue = @EndValue OUTPUT

  SELECT 
		@StartValue as N'@StartValue',
		@EndValue as N'@EndValue'
*/

  DECLARE @EventDetail VARCHAR(4000);
  DECLARE @EventReturnCode INT;

  -- Local variables (Module Id and source Data Object)
  DECLARE @ModuleId BIGINT = [omd].[GetModuleIdByModuleInstanceId](@ModuleInstanceId);

  -- Exception handling
  IF @ModuleId IS NULL
	-- The Module Id cannot be NULL
	BEGIN
	  SET @EventDetail = 'The Module Id was not found for Module Instance Id '''+CONVERT(VARCHAR(10),@ModuleInstanceId)+'''';
	  EXEC [omd].[InsertIntoEventLog] @EventDetail = @EventDetail;

	  THROW 50000,@EventDetail,1;
	END

  -- Figure out what the source is.
  DECLARE @SourceDataObject VARCHAR(255); 
  SELECT @SourceDataObject = DATA_OBJECT_SOURCE FROM omd.MODULE WHERE MODULE_ID = @ModuleId; 

  IF @Debug = 'Y'
	BEGIN
	  PRINT 'For Module Instance Id '+CONVERT(VARCHAR(10),@ModuleInstanceId)+' the following Module Id was found in omd.MODULE: '+CONVERT(VARCHAR(10),@ModuleId)+'.';
	  PRINT 'For Module Id '+CONVERT(VARCHAR(10),@ModuleId)+' the Source Data Object is '+@SourceDataObject+'.';
	END

  -- Exception handling
  IF @ModuleId = NULL OR @ModuleId = 0 
	THROW 50000,'The Module Id could not be retrieved based on the Module Instance Id.',1

  BEGIN TRY
	-- Parse the start value as input, or revert to default.
	DECLARE @StartValueSql VARCHAR(MAX);
	BEGIN
		IF @StartValue IS NOT NULL
			BEGIN
				IF @Debug='Y'
					BEGIN
						PRINT 'A load window start value was provided: '+CONVERT(VARCHAR(100),@StartValue);
					END
					
					SET @StartValueSql = ''''+CONVERT(VARCHAR(100),@StartValue)+'''';
			END
		ELSE
			BEGIN
				SET @StartValueSql = 
'SELECT
	END_VALUE AS NEW_START_VALUE
FROM 
(
	SELECT 
	 ROW_NUMBER() OVER (PARTITION BY A.MODULE_ID ORDER BY INSERT_DATETIME DESC) AS RN
	,END_VALUE
	FROM omd.SOURCE_CONTROL A
	JOIN omd.MODULE_INSTANCE B ON (A.MODULE_INSTANCE_ID = B.MODULE_INSTANCE_ID)
	WHERE B.MODULE_ID = '+CONVERT(VARCHAR(10),@ModuleId)+'
) sub
WHERE RN=1';

				IF @Debug='Y'
					BEGIN
						PRINT 'No load window start value was provided, so the most recent value will be retrieved from the source control table for the source data object.';
						PRINT 'The following code will be used to determin the start value: '+@StartValueSql;
					END
			END
	END

	-- Parse the end value as input, or revert to default.
	DECLARE @EndValueSql VARCHAR(MAX);
	BEGIN
		IF @EndValue IS NOT NULL
			BEGIN
				IF @Debug='Y'
					BEGIN
						PRINT 'A load window end value was provided: '+CONVERT(VARCHAR(100),@EndValue);
					END
					
					SET @EndValueSql = ''''+CONVERT(VARCHAR(100),@EndValue)+'''';
			END
		ELSE
			BEGIN
				SET @EndValueSql = 
'SELECT COALESCE(MAX('+@LoadWindowAttributeName+'),''1900-01-01'') AS END_VALUE
FROM '+@SourceDataObject+' sdo
JOIN omd.MODULE_INSTANCE modinst ON sdo.omd_module_instance_id = modinst.MODULE_INSTANCE_ID
WHERE modinst.EXECUTION_STATUS_CODE=''S''';

				IF @Debug='Y'
					BEGIN
						PRINT 'No load window end value was provided, so the maximum date will be retrieved directly from the source data object.';
						PRINT 'The following code will be used to determin the end value: '+@EndValueSql;
					END
			END
	END
	
	DECLARE @SqlStatement VARCHAR(MAX);
	SET @SqlStatement = '
		  INSERT INTO omd.[SOURCE_CONTROL]
		  (
			 [MODULE_ID]
			,[MODULE_INSTANCE_ID]
			,[INSERT_DATETIME]
			,[START_VALUE]
			,[END_VALUE]
		  )
		  VALUES
		  (
			 '+CONVERT(VARCHAR(10),@ModuleId)+'
			,'+CONVERT(VARCHAR(10),@ModuleInstanceId)+'
			,SYSDATETIME()
			,(  
			   '+@StartValueSql+'
			 ) -- Interval Start Value
		   , (
			   '+@EndValueSql+'
			 ) -- Interval End Value
		  )'

	IF @Debug='Y'
	  PRINT 'Load Window SQL statement is: '+@SqlStatement;      

	EXEC (@SqlStatement);
	
	-- Retrieve values for return.
	SELECT @StartValue = [omd].[GetModuleLoadWindowValue](@ModuleId,1);
	SELECT @EndValue = [omd].[GetModuleLoadWindowValue](@ModuleId,2);

  END TRY 
  BEGIN CATCH
	  -- Logging
	   SET @EventDetail = ERROR_MESSAGE();
	   SET @EventReturnCode = ERROR_NUMBER();
	   
	   EXEC [omd].[InsertIntoEventLog]
		 @ModuleInstanceId = @ModuleInstanceId,
		 @EventDetail = @EventDetail,
		 @EventReturnCode = @EventReturnCode;

	  THROW
  END CATCH

  EndOfProcedure:
  -- End label
END
GO
PRINT N'Altering Procedure [omd].[CreateModuleInstance]...';


GO
/*
Process: Create Module Instance
Input: 
  - Module Code
  - Batch Instance Id
  - Execution runtime Is (e.g. GUID, SPID)
  - Debug flag Y/N
Returns:
  - Module Instance Id
Usage:
	DECLARE @ModuleInstanceId INT
	EXEC [omd].[CreateModuleInstance]
	  @ModuleCode = N'<Module Code / Name>',
	  @ModuleInstanceId = @ModuleInstanceId OUTPUT;
	PRINT @ModuleInstanceId;
*/

ALTER PROCEDURE [omd].[CreateModuleInstance]
	@ModuleCode VARCHAR(255), -- The name of the Module, as identified in the MODULE_CODE attribute in the MODULE table.
	@Query VARCHAR(MAX), -- The query that was passed down from the Module, for reference
	@Debug VARCHAR(1) = 'N',
	@ExecutionRuntimeId VARCHAR(255) = 'N/A',
	@BatchInstanceId INT = 0, -- The Batch Instance Id, if the Module is run from a Batch.
	@ModuleInstanceId INT = NULL OUTPUT
AS
BEGIN

  DECLARE @EventDetail VARCHAR(4000);
  DECLARE @EventReturnCode INT;

  DECLARE @ModuleId INT;
  SELECT @ModuleId = omd.GetModuleIdByName(@ModuleCode);

  -- Exception handling
  -- The Module Id cannot be NULL
  IF @ModuleId IS NULL
  BEGIN
	SET @EventDetail = 'The Module Id was not found for Module Code '''+@ModuleCode+'''';  
	EXEC [omd].[InsertIntoEventLog]
	  @EventDetail = @EventDetail;
  END

  IF @Debug = 'Y'
	PRINT 'For Module Code '+@ModuleCode+' the following Module Id was found in omd.MODULE: '+CONVERT(VARCHAR(10),@ModuleId);

  BEGIN TRY
	INSERT INTO omd.MODULE_INSTANCE 
	(
	  MODULE_ID, 
	  START_DATETIME, 
	  EXECUTION_STATUS_CODE, 
	  NEXT_RUN_INDICATOR, 
	  PROCESSING_INDICATOR, 
	  BATCH_INSTANCE_ID, 
	  MODULE_EXECUTION_SYSTEM_ID, 
	  ROWS_INPUT, 
	  ROWS_INSERTED, 
	  ROWS_UPDATED, 
	  ROWS_DELETED, 
	  ROWS_DISCARDED,
	  ROWS_REJECTED,
	  EXECUTED_CODE
	) 
	VALUES
	(
	  @ModuleId,			-- Module ID
	  SYSDATETIME(),		-- Start Datetime
	  'E',					-- Execution Status Code
	  'P',					-- Next Run Indicator
	  'A',					-- Processing Indicator
	  @BatchInstanceId,		-- Batch Instance Id
	  @ExecutionRuntimeId,  -- Module Execution System Id 
	  0,
	  0,
	  0,
	  0,
	  0,
	  0,
	  @Query
	);

	SET @ModuleInstanceId = SCOPE_IDENTITY();

	IF @Debug = 'Y'
	  PRINT 'A new Module Instance Id '+CONVERT(VARCHAR(10),@ModuleInstanceId)+' has been created for Module Code: '+@ModuleCode;

  END TRY
  BEGIN CATCH

	 -- Logging
	SET @EventDetail = ERROR_MESSAGE();
	SET @EventReturnCode = ERROR_NUMBER();

	EXEC [omd].[InsertIntoEventLog]
	  @ModuleInstanceId = @ModuleInstanceId,
	  @EventDetail = @EventDetail,
	  @EventReturnCode = @EventReturnCode;

	THROW
  END CATCH
  
END
GO
PRINT N'Altering Procedure [omd].[ModuleEvaluation]...';


GO
/*
Process: Module Evaluation
Purpose: Checks if the Module Instance is able to proceed, based on the state of all Module Instances for the particular Module.
Input: 
  - Module Instance Id
  - Debug flag Y/N (default to N)
Returns:
  - ProcessIndicator
Usage:
    DECLARE @ProcessIndicator VARCHAR(10);
    EXEC [omd].[ModuleEvaluation]
      @ModuleInstanceId = <Id>,
      @ProcessIndicator = @ProcessIndicator OUTPUT;
    PRINT @ProcessIndicator;
*/

ALTER PROCEDURE [omd].[ModuleEvaluation]
	@ModuleInstanceId INT, -- The Batch Instance Id, if the Module is run from a Batch.
	@Debug VARCHAR(1) = 'N',
	@ModuleInstanceIdColumnName VARCHAR(255) = 'MODULE_INSTANCE_ID',
	@ProcessIndicator VARCHAR(10) = NULL OUTPUT
AS
BEGIN
  SET NOCOUNT ON;
  SET ANSI_WARNINGS OFF; -- Suppress NULL elimination warning within SET operation.

  DECLARE @EventDetail VARCHAR(4000);
  DECLARE @EventReturnCode INT;

  DECLARE @ModuleId INT;
  DECLARE @BatchId INT;
  DECLARE @MinimumActiveModuleInstance INT;
  DECLARE @ActiveModuleInstanceCount INT;
  DECLARE @BatchModuleInactiveIndicator VARCHAR(3);

  IF @Debug = 'Y'
    PRINT '-- Beginning of Module Evaluation for Module Instance Id '+CONVERT(VARCHAR(10),@ModuleInstanceId);

  SELECT @ModuleId = omd.GetModuleIdByModuleInstanceId(@ModuleInstanceId);

  -- Exception handling
  -- The Module Id cannot be NULL
  IF @ModuleId IS NULL
  BEGIN
    SET @EventDetail = 'The Module Id was not found for Module Instance Id '''+@ModuleInstanceId+'''';  
    EXEC [omd].[InsertIntoEventLog]
  	  @EventDetail = @EventDetail;
  END

  IF @Debug = 'Y'
    PRINT 'For Module Instance Id '+CONVERT(VARCHAR(10),@ModuleInstanceId)+' the Module Id '+CONVERT(VARCHAR(10),@ModuleId)+' was found in omd.MODULE.';

  /* 
    Region: Check for multiple active Module Instances
	Multiple active instances indicate corruption in the DIRECT repository.
  */
  IF @Debug = 'Y'
    PRINT CHAR(13)+'-- Beginning of active instance checks.';

  -- Check for the lowest instance of the Module Instances since the process must continue if it's the first of the started instances for the particular Module.  
  SELECT @MinimumActiveModuleInstance =
    MIN(MODULE_INSTANCE_ID)  
  FROM omd.MODULE_INSTANCE
  WHERE EXECUTION_STATUS_CODE = 'E' 
    AND MODULE_ID = @ModuleId
  GROUP BY MODULE_ID
        
  -- Check if there are no additional running instances other than the current Module Instance. The count should be 1.
  SELECT @ActiveModuleInstanceCount = 
    COUNT(*)
  FROM omd.MODULE_INSTANCE
  WHERE EXECUTION_STATUS_CODE = 'E' 
     AND MODULE_ID = @ModuleId
     AND MODULE_INSTANCE_ID != @ModuleInstanceId
  GROUP BY MODULE_ID

  IF @Debug = 'Y'
  BEGIN
    PRINT 'The number of active Module Instances is '+COALESCE(CONVERT(VARCHAR(10),@ActiveModuleInstanceCount),'0')+'.';
    PRINT 'The minimum active Module Instance Id is '+COALESCE(CONVERT(VARCHAR(10),@MinimumActiveModuleInstance),'0')+'.';
  END

  IF (@ActiveModuleInstanceCount IS NULL) OR (@ActiveModuleInstanceCount IS NOT NULL AND @MinimumActiveModuleInstance = @ModuleInstanceId)
    BEGIN
	  -- Continue, either there is only 1 active instance for the Module (this one) OR this instance is the first of many running instances and this one should be allowed to continue.
	  IF @Debug = 'Y'
	    PRINT 'Either there is only 1 active instance for the Module (this one) OR this instance is the first (MIN) of many running instances and should be allowed to continue.'
     
	 -- Go to the next step in the process.
	  GOTO BatchModuleEvaluation
	END
  ELSE -- There are already multiple running instances for the same Module, the process must be aborted.
	BEGIN
	  IF @Debug = 'Y'
	    PRINT 'There are already multiple running instances for the same Module, the process must be aborted. (abort and go to end of procedure).'

	  -- Call the Abort event.
	  EXEC [omd].[UpdateModuleInstance]
		@ModuleInstanceId = @ModuleInstanceId,
		@EventCode = N'Abort',
		@Debug = @Debug

      SET @ProcessIndicator = 'Abort';
	  GOTO EndOfProcedure
	  -- End
	END

  BatchModuleEvaluation:
  /* 
    Region: Batch/Module relationship validation.
	In case the Module is called from a parent Batch this task verifies if the administration is done properly
	and if the Module is disabled as part of the Batch configuration (BATCH_MODULE).

	If the current instance is started from a Batch (Batch Instance <> 0) then the Batch / Module flag must be set to INACTIVE_INDICATOR='N'
	If the current instance has a Batch Instance Id (or Batch Id) of 0 then this step can be skipped, as the Module was not started by a Batch.
  */

  SELECT @BatchId = omd.GetBatchIdByModuleInstanceId(@ModuleInstanceId);

  -- Exception handling
  -- The Batch Id cannot be NULL
  IF @BatchId IS NULL
  BEGIN
    SET @EventDetail = 'The Batch Id was not found for Module Instance Id '''+@ModuleInstanceId+'''';  
    EXEC [omd].[InsertIntoEventLog]
  	  @EventDetail = @EventDetail;
  END

  IF @Debug='Y'
    PRINT CHAR(13)+'-- Start of Batch / Module relationship evalation step.';
	PRINT 'The Batch Id found is '+CONVERT(VARCHAR(10),@BatchId);
	
  IF @BatchId = 0 -- The Module was run stand-alone (not from a Batch).
    BEGIN
	  -- The Module Instance was not started from a Batch, so processing can skip this step and continue.
	  IF @Debug='Y'
        PRINT 'The Module Instance was not started from a Batch (0), so processing can skip this step and continue to Rollback Evaluation.';

	  GOTO RollBackEvaluation -- Go to the next process step after this section.
    END
  ELSE -- Batch Id has a value, so the Module was run from a Batch and we need to check if the Module is active for the Batch.
    BEGIN

	  IF @Debug='Y'
        PRINT 'The Module Instance was  started from a Batch (Id: '+CONVERT(VARCHAR(10),@BatchId)+'), so processing will evaluate if the Batch/Module registration is correct.';

	  -- The Module Instance was started by a Batch, so we must check if the Module is allowed to run.
	  SELECT @BatchModuleInactiveIndicator= omd.[GetBatchModuleActiveIndicatorValue](@BatchId,@ModuleId)	  

	  IF @Debug='Y'
		PRINT 'The Batch / Module inactive flag value is '+@BatchModuleInactiveIndicator;

      IF (@BatchModuleInactiveIndicator='Y') -- Skip
      BEGIN
	  	IF @Debug='Y'
		  PRINT 'The Module Instance will be skipped / cancelled';

	    -- If the inactive indicator at Batch/Module level is set to 'Y' the process is disabled in the framework.
	    -- In this case, the Module must be skipped / cancelled (was attempted to be run, but not allowed).
	   
	    -- Call the Cancel (skip) event.
	    EXEC [omd].[UpdateModuleInstance]
	  	  @ModuleInstanceId = @ModuleInstanceId,
		  @EventCode = N'Cancel',
	      @Debug = @Debug

		SET @ProcessIndicator = 'Cancel';
	    GOTO EndOfProcedure
		-- End
      END

	  IF (@BatchModuleInactiveIndicator = 'N/A') -- Abort
        BEGIN
	  	  IF @Debug='Y'
		    PRINT 'The Module Instance will be aborted.';

	      -- If the inactive indicator at Batch/Module level is NULL then there is an error in the framework registration / setup.
	      -- In this case, the Module must be aborted. The module was attempted to be run form a Batch it is not registered for).
	  
	      -- Call the Abort event.
	      EXEC [omd].[UpdateModuleInstance]
		    @ModuleInstanceId = @ModuleInstanceId,
		    @EventCode = N'Abort',
		    @Debug = @Debug

          SET @ProcessIndicator = 'Abort';
	      GOTO EndOfProcedure
	      -- End
        END
	  ELSE -- Continue with regular processing
	    GOTO RollBackEvaluation

	  -- The procedure should not be able to end in this part.
	  -- Logging and exception handling
	  SET @EventDetail = 'Incorrect Module Evaluation path encountered during BatchModuleEvaluation step.'

	  EXEC [omd].[InsertIntoEventLog]
	    @ModuleInstanceId = @ModuleInstanceId,
		@EventDetail = @EventDetail;
		
      GOTO ModuleFailure
	   --THROW 50000,@EventDetail,1;	   
	END


  RollBackEvaluation:
  /* 
    Region: rollback.
	Any erroneous previous instances must be rolled-back before processing can continue.
  */

  IF @Debug='Y'
	PRINT CHAR(13)+'-- Start of rollback evaluation process step.';

  DECLARE @PreviousModuleInstanceTable TABLE
  (
    LastBatchInstanceID INT,
    LastModuleInstanceID INT ,
    LastStartTime DATETIME2(7),
    LastEndTime DATETIME2(7),
    LastExecutionStatus VARCHAR(1),
    LastNextExecutionFlag VARCHAR(1),
    LastModuleInstanceIDList VARCHAR(MAX),
    InactiveIndicator VARCHAR(1)
  );

  INSERT @PreviousModuleInstanceTable 
  SELECT * FROM [omd].[GetPreviousModuleInstanceDetails](@ModuleId,@BatchId)

  -- If the previously completed Module Instance (for the same Module) is set to skip OR the module is set to inactive the run must be cancelled.
  IF ((SELECT LastNextExecutionFlag FROM @PreviousModuleInstanceTable) = 'C') OR ((SELECT InactiveIndicator FROM @PreviousModuleInstanceTable) = 'Y')
    BEGIN
	  IF @Debug='Y'
	    PRINT 'The last Execution Flag is ''C'' OR the Inactive Indicator at Module level is ''Y''. The process will be skipped / cancelled.';

	  IF @Debug='Y'
	    PRINT 'The Module Instance will be skipped / cancelled';

	  -- Call the Cancel (skip) event.
	  EXEC [omd].[UpdateModuleInstance]
	    @ModuleInstanceId = @ModuleInstanceId,
		@EventCode = N'Cancel',
	    @Debug = @Debug

	  SET @ProcessIndicator = 'Cancel';
	  GOTO EndOfProcedure
   END

  -- Proceed with success 
  -- If the previous run for the module (the previous Module Instance) was completed successfully and the Module is not disabled, the process can report 'proceed' for
  -- any code execution in the body (e.g. the ETL itself).
  IF ((SELECT LastNextExecutionFlag FROM @PreviousModuleInstanceTable) = 'P') AND ((SELECT InactiveIndicator FROM @PreviousModuleInstanceTable) != 'Y')
    BEGIN
	  IF @Debug='Y'
	    PRINT 'The last Execution Flag is ''P'' AND the Inactive Indicator at Module level is not ''Y''. The process can proceed (no rollback is required).';

	  IF @Debug='Y'
		PRINT 'The Module Instance will be set to proceed';

	  EXEC [omd].[UpdateModuleInstance]
	    @ModuleInstanceId = @ModuleInstanceId,
		@EventCode = N'Proceed',
	    @Debug = @Debug

	   SET @ProcessIndicator = 'Proceed';
	   GOTO EndOfProcedure
    END

  -- Proceed with RollBack.
  -- If the previous Module Instance is set to Rollback, this will trigger the current Module instance to do so before proceeding.
  IF ((SELECT LastNextExecutionFlag FROM @PreviousModuleInstanceTable) = 'R') AND ((SELECT InactiveIndicator FROM @PreviousModuleInstanceTable) != 'Y')
    BEGIN
	  IF @Debug='Y'
	    PRINT 'The last Execution Flag is ''R'' AND the Inactive Indicator at Module level is not ''Y''. The process should perform a rollback.';

	  IF @Debug='Y'
		PRINT 'The Module Instance will be set to rollback';

	  EXEC [omd].[UpdateModuleInstance]
	    @ModuleInstanceId = @ModuleInstanceId,
		@EventCode = N'Rollback',
	    @Debug = @Debug

	  SET @ProcessIndicator = 'Rollback';
	  GOTO CallRollback
    END

  /*
    Region: execution of rollback.
  */

	CallRollback:
  
  IF @Debug='Y'
	PRINT CHAR(13)+'-- Start of rollback evaluation process step.';

  BEGIN TRY
      -- Call the rollback procedure for the current Module.
	  -- Technically, this is rolling back of the previous Module Instance.
      -- This has to happen in the same transaction block to prevent process setting to commence before rollback ends.

	BEGIN -- Rollback
	  DECLARE @ModuleInstanceIdList VARCHAR(MAX);
	  SET @ModuleInstanceIdList = (SELECT LastModuleInstanceIDList FROM @PreviousModuleInstanceTable);

	  IF @Debug='Y'
	    PRINT 'Input variables are Module '+CONVERT(VARCHAR(10),@ModuleId)+' with Previous Module Instance Id list '+@ModuleInstanceIdList+'.';

	  DECLARE @SqlStatement VARCHAR(MAX);
	  --DECLARE @AreaCode VARCHAR(10);
	  --SELECT @AreaCode = AREA_CODE FROM omd.MODULE WHERE MODULE_ID=@ModuleId;
	  DECLARE @TableCode VARCHAR(255);
	  SELECT @TableCode = DATA_OBJECT_TARGET FROM omd.MODULE WHERE MODULE_ID=@ModuleId; 

	  IF @Debug='Y'
	  BEGIN
		--PRINT 'The Area Code for Module '+CONVERT(VARCHAR(10),@ModuleId)+' is '+@AreaCode+'.';
		PRINT 'The Table Code (DATA_OBJECT_TARGET) for Module '+CONVERT(VARCHAR(10),@ModuleId)+' is '+@TableCode+'.';
	  END

	  -- Rollback
	  BEGIN
	    BEGIN TRY
		  IF @Debug='Y'
		  PRINT 'Rollback.';

		  DECLARE @LocalAreaCode VARCHAR(255) = (SELECT omd.GetModuleAreaByModuleId(@ModuleId));

		  IF @TableCode <> 'NA'
		  BEGIN
		  --IF @LocalAreaCode = 'INT'
		    --SET @SqlStatement = 'DELETE FROM '+@TableCode+' WHERE (omd_module_instance_id IN '+@ModuleInstanceIdList+') OR (omd_update_module_instance_id IN '+@ModuleInstanceIdList+')';
		  --ELSE
		    SET @SqlStatement = 'DELETE FROM '+@TableCode+' WHERE '+@ModuleInstanceIdColumnName+' IN '+@ModuleInstanceIdList;

		  IF @Debug='Y'
		    PRINT 'Rollback SQL statement is: '+@SqlStatement;

		  EXEC (@SqlStatement);

		  SET @SqlStatement = 'DELETE FROM omd.SOURCE_CONTROL WHERE MODULE_INSTANCE_ID IN '+@ModuleInstanceIdList;

		  IF @Debug='Y'
		    PRINT 'Source Control Rollback SQL statement is: '+@SqlStatement;

		  EXEC (@SqlStatement);
		  END
		  ELSE
		  BEGIN
		  	IF @Debug='Y'
				PRINT 'No rollback is required for '+@TableCode;
		  END
			
		  -- Not implemented expiry date reset. Insert only!
		  --UPDATE <Table Code> SET EXPIRY_DATETIME = '9999-12-31', CURRENT_RECORD_INDICATOR = 'Y' WHERE MODULE_INSTANCE_ID IN <List>;

	    END TRY
	    BEGIN CATCH
		  -- Module Failure
		  EXEC [omd].[UpdateModuleInstance]
			@ModuleInstanceId = @ModuleInstanceId,
			@Debug = @Debug,
			@EventCode = 'Failure';
	      SET @ProcessIndicator = 'Failure';
		  THROW
	    END CATCH
	  END

	END -- End of Rollback


    -- After rollback is completed, the process is allowed to continue.
    IF @Debug='Y'
      PRINT 'The Module Instance will be set to proceed';

    EXEC [omd].[UpdateModuleInstance]
	   @ModuleInstanceId = @ModuleInstanceId,
	   @EventCode = N'Proceed',
	   @Debug = @Debug

	SET @ProcessIndicator = 'Proceed';
    GOTO EndOfProcedure
  END TRY
  BEGIN CATCH
      -- Module Failure
    EXEC [omd].[UpdateModuleInstance]
         @ModuleInstanceId = @ModuleInstanceId,
      @Debug = @Debug,
      @EventCode = 'Failure';
	SET @ProcessIndicator = 'Failure';

	-- Logging and exception handling
	SET @EventDetail = 'Failure during rollack process in Module Evaluation, with error: '+ERROR_MESSAGE();
    SET @EventReturnCode = ERROR_NUMBER();

	EXEC [omd].[InsertIntoEventLog]
	  @ModuleInstanceId = @ModuleInstanceId,
	  @EventDetail = @EventDetail,
	  @EventReturnCode = @EventReturnCode;

    THROW
  END CATCH
  -- All branches completed

  ModuleFailure:
  -- The procedure should not be able to end in this part, so this is just to be sure there is a failure reported when this happens.
    -- Module Failure
  EXEC [omd].[UpdateModuleInstance]
    @ModuleInstanceId = @ModuleInstanceId,
    @Debug = @Debug,
    @EventCode = 'Failure';
  SET @ProcessIndicator = 'Failure';

  /*
    Region: end of processing, final step.
  */

  EndOfProcedure:
   -- End label

  IF @Debug = 'Y'
  BEGIN
     BEGIN TRY
       PRINT 'Module Instance Id '+CONVERT(VARCHAR(10),@ModuleInstanceId)+' was processed';
       PRINT 'The result (processing indicator) is '+@ProcessIndicator;  
       PRINT CHAR(13)+'-- Module Evaluation completed.';
	 END TRY
	 BEGIN CATCH

	    -- Logging and exception handling
	    SET @EventDetail = ERROR_MESSAGE();
        SET @EventReturnCode = ERROR_NUMBER();

	    EXEC [omd].[InsertIntoEventLog]
	      @ModuleInstanceId = @ModuleInstanceId,
		  @EventDetail = @EventDetail,
		  @EventReturnCode = @EventReturnCode;

	   THROW

	 END CATCH
  END
END
GO
PRINT N'Altering Procedure [omd].[RunModule]...';


GO
/*
Process: Run Module
Purpose: Executes a data logistics process / query in a DIRECT wrapper.
Input: 
  - Module Code
  - Query (statement to execute)
  - Debug flag Y/N (default to N)
Returns:
  - Process result (success, failure)
Usage:
    DECLARE @QueryResult VARCHAR(10);
    EXEC [omd].[RunModule]
      @ModuleCode = '<>',
	  @Query = '<>'
      @QueryResult = @QueryResult OUTPUT;
    PRINT @QueryResult;

	or

    EXEC [omd].[RunModule]
      @ModuleCode = '<>',
      @Debug = 'Y'
	  @Query = '<>';

*/

ALTER PROCEDURE omd.RunModule
	-- Add the parameters for the stored procedure here
	@ModuleCode VARCHAR(255),
	@Query VARCHAR(MAX) = NULL, -- An input query, which can be custom or calling a procedure. This will override the executable defined for the Module
    @BatchInstanceId INT = 0, -- The Batch Instance Id, if the Module is run from a Batch.
	@Debug VARCHAR(1) = 'N',
    @ModuleInstanceIdColumnName VARCHAR(255) = 'MODULE_INSTANCE_ID', -- Used to override if certain solutions have other columns names as audit trail id/ module instance id.
    @ModuleInstanceId BIGINT = NULL OUTPUT,
	@QueryResult VARCHAR(10) = NULL OUTPUT
AS
BEGIN

  IF @Debug = 'Y'
	PRINT 'Start of the RunModule process.';

  -- Retrieve the code to execute, if not overridden by providing the @query parameter.
  IF @Query IS NULL
    BEGIN
        SELECT @Query = [EXECUTABLE] FROM [omd].[MODULE] WHERE MODULE_CODE = @ModuleCode;

        IF @Debug = 'Y'
            PRINT 'The executable code retrieved is: '''+@Query+'''.';
    END
  ELSE
    BEGIN
        IF @Debug = 'Y'
            PRINT 'A code override has been provided: '''+@Query+'''.';
    END

  -- Create Module Instance
  EXEC [omd].[CreateModuleInstance]
    @ModuleCode = @ModuleCode,
    @Query = @Query,
    @Debug = @Debug,
    @BatchInstanceId = @BatchInstanceId, -- The Batch Instance Id, if the Module is run from a Batch.
    @ModuleInstanceId = @ModuleInstanceId OUTPUT;
  
  -- Module Evaluation
  DECLARE @ProcessIndicator VARCHAR(10);
  EXEC [omd].[ModuleEvaluation]
    @ModuleInstanceId = @ModuleInstanceId,
    @Debug = @Debug,
    @ModuleInstanceIdColumnName = @ModuleInstanceIdColumnName,
    @ProcessIndicator = @ProcessIndicator OUTPUT;

    IF @Debug = 'Y'
      PRINT @ProcessIndicator;
  
  IF @ProcessIndicator NOT IN ('Abort','Cancel') -- These are end-states for the process.
    BEGIN TRY
      /*
	    Main ETL block
	  */

      -- Replace placeholder variable(s)
      SET @Query = REPLACE(@Query,'@ModuleInstanceId', @ModuleInstanceId)

      -- Run the code
	  DECLARE @RowCount NUMERIC(38)
      EXEC(@Query);
	  SET @RowCount = @@ROWCOUNT;

	  IF @Debug = 'Y' PRINT 'The returned row count is ' +CONVERT(VARCHAR(10),@RowCount)
      /*
	    Wrap up
	  */

      IF @Debug = 'Y'
        PRINT 'Success pathway';

      -- Module Success
      EXEC [omd].[UpdateModuleInstance]
        @ModuleInstanceId = @ModuleInstanceId,
		@RowCountInsert = @RowCount,
        @Debug = @Debug,
        @EventCode = 'Success'

	  SET @QueryResult = 'Success';

   END TRY
    BEGIN CATCH
      IF @Debug = 'Y'
        PRINT 'Failure pathway';

      -- Module Failure
      EXEC [omd].[UpdateModuleInstance]
        @ModuleInstanceId = @ModuleInstanceId,
		@RowCountInsert = @RowCount,
        @Debug = @Debug,
        @EventCode = 'Failure';
	  
	  SET @QueryResult = 'Failure';

	   -- Logging
	   DECLARE @EventDetail VARCHAR(4000) = ERROR_MESSAGE(),
               @EventReturnCode int = ERROR_NUMBER();

	  EXEC [omd].[InsertIntoEventLog]
	    @ModuleInstanceId = @ModuleInstanceId,
		@EventDetail = @EventDetail,
		@EventReturnCode = @EventReturnCode;

	  THROW
    END CATCH
  ELSE
    SET @QueryResult = @ProcessIndicator;

END
GO
PRINT N'Refreshing Procedure [omd].[RunBatch]...';


GO
EXECUTE sp_refreshsqlmodule N'[omd].[RunBatch]';


GO
/*
Post-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.		
 Use SQLCMD syntax to include a file in the post-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the post-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/

/*
  Reference data
  DIRECT model revision 21
*/

set nocount on;

/* Layer */
insert into omd.LAYER
select *
from (
		/* LAYER_CODE, LAYER_DESCRIPTION */
	values (N'Integration', N'The Integration Layer')
		 , (N'Presentation', N'The Presentation Layer')
		 , (N'Staging', N'The Staging Layer')
		 , (N'Maintenance', N'Internal Data Solution')
	) as refData(LAYER_CODE, LAYER_DESCRIPTION)
where not exists (
		select null
		from omd.LAYER
		where LAYER.LAYER_CODE = refData.LAYER_CODE
		);

/* Area */
insert into omd.AREA
select *
from (
		  /* AREA_CODE, LAYER_CODE, AREA_DESCRIPTION */
	values (N'HELPER', N'Presentation', N'The Helper Area')
		 , (N'PSA', N'Staging', N'The Persistent Staging Area')
		 , (N'INT', N'Integration', N'The Integration Area')
		 , (N'INTPR', N'Integration', N'The Interpretation Area')
		 , (N'PRES', N'Presentation', N'The Presentation Area')
		 , (N'STG', N'Staging', N'The Staging Area of the Staging Layer')
		 , (N'SYNC', N'Staging', N'Synchronization of the production History Area of the Staging Layer for build and test')
		 , (N'Maintenance', N'Maintenance', N'Internal Data Solution')
	) as refData(AREA_CODE, LAYER_CODE, AREA_DESCRIPTION)
where not exists (
		select null
		from omd.AREA
		where omd.AREA.AREA_CODE = refData.AREA_CODE
		);

/* Execution Status */
insert into omd.EXECUTION_STATUS
select *
from (
		  /* EXECUTION_STATUS_CODE, EXECUTION_STATUS_DESCRIPTION */
	values (N'A', N'Aborted')
		 , (N'C', N'Cancelled / skipped')
		 , (N'E', N'Executing')
		 , (N'F', N'Failure')
		 , (N'S', N'Succes')
	) as refData(EXECUTION_STATUS_CODE, EXECUTION_STATUS_DESCRIPTION)
where not exists (
		select null
		from omd.EXECUTION_STATUS
		where omd.EXECUTION_STATUS.EXECUTION_STATUS_CODE = refData.EXECUTION_STATUS_CODE
		);

/* Next Run Indicator */
insert into omd.NEXT_RUN_INDICATOR
select *
from (
		  /* NEXT_RUN_INDICATOR, NEXT_RUN_INDICATOR_DESCRIPTION */
	values (N'C', N'Cancelled / skipped. Administrators can manually set this code to for the Next Run Indicator.')
		, (N'P', N'Proceed. The next run of the Batch/Module to set to continue processing.')
		, (N'R', N'Rollback . Upon failure the Next Run Indicator is updated to ‘R’ to signal a rollback.')
	) as refData(NEXT_RUN_INDICATOR, NEXT_RUN_INDICATOR_DESCRIPTION)
where not exists (
		select null
		from omd.NEXT_RUN_INDICATOR
		where omd.NEXT_RUN_INDICATOR.NEXT_RUN_INDICATOR = refData.NEXT_RUN_INDICATOR
		);

/* Processing Indicator */
insert into omd.PROCESSING_INDICATOR
select *
from (
		  /* PROCESSING_INDICATOR, PROCESSING_INDICATOR_DESCRIPTION */
	values (N'A', N'Abort. This indicates that the Batch/Module is already running.')
		 , (N'C', N'Cancel / skip. The process has determined that it is not necessary to run this ETL process.')
		 , (N'P', N'Proceed. The Instance can continue on to the next step of the processing.')
		 , (N'R', N'Rollback. During rollback processing the Processor Indicator is set to R.')
	) as refData(PROCESSING_INDICATOR, PROCESSING_INDICATOR_DESCRIPTION)
where not exists (
		select null
		from omd.PROCESSING_INDICATOR
		where omd.PROCESSING_INDICATOR.PROCESSING_INDICATOR = refData.PROCESSING_INDICATOR
		);

/* Event Type */
insert into omd.EVENT_TYPE
select *
from (
		  /* EVENT_TYPE_CODE, EVENT_TYPE_DESCRIPTION */
	values (N'1', N'Infrastructural error.')
		 , (N'2', N'Internal data integration process error or system generated event.')
		 , (N'3', N'Custom exception handling that has been implemented in ETL (Error Bitmaps).')
	) as refData(EVENT_TYPE_CODE, EVENT_TYPE_DESCRIPTION)
where not exists (
		select null
		from omd.EVENT_TYPE
		where omd.EVENT_TYPE.EVENT_TYPE_CODE = refData.EVENT_TYPE_CODE
		);

/* Batch */
set identity_insert omd.BATCH on;
insert into omd.BATCH (BATCH_ID, BATCH_CODE, FREQUENCY_CODE, BATCH_DESCRIPTION, INACTIVE_INDICATOR)
select *
from (
		  /* BATCH_ID, BATCH_CODE, FREQUENCY_CODE, BATCH_DESCRIPTION, INACTIVE_INDICATOR */
	values (0, N'Default Batch', N'Continuous', N'Placeholder value for dummy Batch runs', N'N')
	) as refData(BATCH_ID, BATCH_CODE, FREQUENCY_CODE, BATCH_DESCRIPTION, INACTIVE_INDICATOR)
where not exists (
		select null
		from omd.BATCH
		where omd.BATCH.BATCH_ID = refData.BATCH_ID
		);
set identity_insert omd.BATCH off;

/* Batch Instance */
set identity_insert omd.BATCH_INSTANCE on;
insert into omd.BATCH_INSTANCE (BATCH_INSTANCE_ID, BATCH_ID, START_DATETIME, END_DATETIME, PROCESSING_INDICATOR, NEXT_RUN_INDICATOR, EXECUTION_STATUS_CODE, BATCH_EXECUTION_SYSTEM_ID)
select *
from (
		  /* BATCH_INSTANCE_ID, BATCH_ID, START_DATETIME, END_DATETIME, PROCESSING_INDICATOR, NEXT_RUN_INDICATOR, EXECUTION_STATUS_CODE, BATCH_EXECUTION_SYSTEM_ID */
	values (0, 0, CAST(N'1900-01-01T00:00:00.000' AS DateTime), CAST(N'2018-10-17T15:07:44.843' AS DateTime), N'P', N'P', N'S', N'N/A')
	) as refData(BATCH_INSTANCE_ID, BATCH_ID, START_DATETIME, END_DATETIME, PROCESSING_INDICATOR, NEXT_RUN_INDICATOR, EXECUTION_STATUS_CODE, BATCH_EXECUTION_SYSTEM_ID)
where not exists (
		select null
		from omd.BATCH_INSTANCE
		where omd.BATCH_INSTANCE.BATCH_INSTANCE_ID = refData.BATCH_INSTANCE_ID
		);
set identity_insert omd.BATCH_INSTANCE off;

/* Module */
set identity_insert omd.MODULE on;
insert into omd.MODULE (MODULE_ID, MODULE_CODE, MODULE_DESCRIPTION, MODULE_TYPE, DATA_OBJECT_SOURCE, DATA_OBJECT_TARGET, AREA_CODE, FREQUENCY_CODE, INACTIVE_INDICATOR, [EXECUTABLE])
select *
from (
	values (0, 'Default Module', 'Placeholder value for dummy Module runs', 'ETL', 'N/A', 'N/A', 'Maintenance', 'Continuous', 'N', 'SELECT NULL')
	) as refData(MODULE_ID, MODULE_CODE, MODULE_DESCRIPTION, MODULE_TYPEE, DATA_OBJECT_SOURCE, DATA_OBJECT_TARGET, AREA_CODE, FREQUENCY_CODE, INACTIVE_INDICATOR, [EXECUTABLE])
where not exists (
		select null
		from omd.MODULE
		where omd.MODULE.MODULE_ID = refData.MODULE_ID
		);
set identity_insert omd.MODULE off;

/* Module Instance */
set identity_insert omd.MODULE_INSTANCE on;
insert into omd.MODULE_INSTANCE (MODULE_INSTANCE_ID, MODULE_ID, BATCH_INSTANCE_ID, START_DATETIME, END_DATETIME, PROCESSING_INDICATOR, NEXT_RUN_INDICATOR, EXECUTION_STATUS_CODE, MODULE_EXECUTION_SYSTEM_ID, ROWS_INPUT, ROWS_INSERTED, ROWS_UPDATED, ROWS_DELETED, ROWS_DISCARDED, ROWS_REJECTED, EXECUTED_CODE)
select *
from (
	  values (0, 0, 0,'1900-01-01', '9999-12-31', 'P', 'P', 'S', 'N/A',0,0,0,0,0,0, 'N/A')
	) as refData(MODULE_INSTANCE_ID, MODULE_ID, BATCH_INSTANCE_ID, START_DATETIME, END_DATETIME, PROCESSING_INDICATOR, NEXT_RUN_INDICATOR, EXECUTION_STATUS_CODE, MODULE_EXECUTION_SYSTEM_ID, ROWS_INPUT, ROWS_INSERTED, ROWS_UPDATED, ROWS_DELETED, ROWS_DISCARDED, ROWS_REJECTED, EXECUTED_CODE)
where not exists (
		select null
		from omd.MODULE_INSTANCE
		where omd.MODULE_INSTANCE.MODULE_INSTANCE_ID = refData.MODULE_INSTANCE_ID
		);
set identity_insert omd.MODULE_INSTANCE off;
--Local or manage-instance deploymenty only
--:r .\Queue_Job_Batch.sql
--:r .\Queue_Job_Module.sql
GO

GO
PRINT N'Checking existing data against newly created constraints';


GO
USE [$(DatabaseName)];


GO
ALTER TABLE [omd].[SOURCE_CONTROL] WITH CHECK CHECK CONSTRAINT [FK_MODULE_INSTANCE_SOURCE_CONTROL];


GO
PRINT N'Update complete.';


GO
